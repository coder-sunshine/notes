# vue3设计思想

声明式框架和命令式框架有什么区别呢？可以简单举个例子就知道了,到餐厅吃面

## 框架对比

### 命令式框架

命令式就是需要一个个的把指令都执行

1. 下单
2. 烧水
3. 放面
4. 放调料
5. 打捞
6. 端给顾客

这样才能得到一碗面条

### 声明式框架

声明式就是不关心执行的过程，只关心结果，到餐厅下单，然后等面端上来就行了。

### 命令式编程(jq示例)

```js
$('#app')
  .text('hello world')
  .on('click', () => {
    console.log('点击')
  })
```

在 jQuery 中，我们需要**手动操作 DOM**，不仅代码冗长，而且容易引入状态管理混乱的问题。

### 声明式编程(vue示例)

```vue
<div @click="() => console.log('点击')">hello world</div>
```

Vue 直接通过 **模板语法** 绑定事件，省去了操作 DOM 的步骤，使代码更加直观、简洁。

### 声明式和命令式框架主要区别

| 特性           | Vue(声明式)                            | jq(命令式)                            |
| -------------- | -------------------------------------- | ------------------------------------- |
| **数据与视图** | 通过**数据驱动视图**，只需关注数据变化 | 需要**手动更新 DOM**                  |
| **代码组织**   | **采用组件化开发**                     | 业务逻辑和 DOM 操作混杂，代码较为分散 |
| **状态管理**   | **自动追踪依赖，响应式更新视图**       | 需要手动管理状态和数据同步            |

Vue 的声明式编程方式，使得代码**更简洁、可维护**，并大幅提升了开发效率。

> [!TIP] 注：
> 关于性能方面，因人而异，最优情况下，命令式会比声明式的性能更优

总结：

> [!TIP] 用一句话来描述：
> 命令式 UI 就是命令框架怎么做，最终达到我们做什么的目的
> 声明式 UI 就是告诉框架做什么，具体怎么做我们不关心。

## 组合式api

**选项式 API**（Options API）通过 data、methods、computed 等选项组织代码，逻辑容易分散。

```js
export default {
  data() {
    return {
      count: 0,
    }
  },
  computed: {
    doubleCount() {
      return this.count * 2
    },
  },
  methods: {
    increment() {
      this.count++
    },
  },
}
```

**组合式 API** （Composition API）使用 setup() 统一管理逻辑，支持逻辑复用（composition function），更适合 TypeScript 开发，代码更清晰、可维护性更高。

```js
import { ref, computed } from 'vue'

const count = ref(0)
const doubleCount = computed(() => count.value * 2)

const increment = () => {
  count.value++
}
```

> [!IMPORTANT] 总结：
>
> | 特性               | 选项式 API                            | 组合式 API                            |
> | ------------------ | ------------------------------------- | ------------------------------------- |
> | **代码组织**       | 按 `data`、`methods`、`computed` 组织 | 逻辑集中管理，更清晰                  |
> | **逻辑复用**       | 使用 `mixins`，可能有冲突             | 使用 `composition function`，更易复用 |
> | **TypeScript兼容** | 支持一般                              | 更加友好                              |

## 虚拟DOM

在 vue 中，使用虚拟 dom 创建真实 dom，我们所编写的模板，就是虚拟 dom，而非真实 dom
vue 尽可能通过虚拟 dom 使用 diff 算法找到本次更新差异的点，进行更新或者渲染
如何创建一个虚拟dom：

```js
const vnode = h('div', 'hello world')
```

## 运行时与编译时

Vue 3 源码设计中，将框架的运行过程拆分为两个阶段：

| 阶段       | 作用                                                               |
| ---------- | ------------------------------------------------------------------ |
| **编译时** | 解析 `.vue` 模板，将其转换为**渲染函数**（`render`），在构建时完成 |
| **运行时** | 执行渲染函数，**创建虚拟 DOM**，并最终更新到真实 DOM               |

### 示例 编译前的代码

```vue
<!-- HelloWorld.vue -->
<template>
  <div>hello world</div>
</template>
```

### 编译后的转换为 js 的代码

```js
const HelloWorld = {
  render() {
    return h('div', 'hello world')
  },
}
```

### 为什么 Vue 需要编译时优化?

✅ 提前优化：提高运行时效率。

## 组件化

Vue 的**组件化架构**，让我们可以将 UI 拆分成**可复用的组件**，实现更好的模块化和维护性。

**组件化的核心优势：**

✅ **代码复用**：相同的 UI 逻辑可以封装成组件，多次复用。

✅ **逻辑清晰**：每个组件独立维护自己的状态和逻辑，增强可维护性。

✅ **提高开发效率**：组件化开发，使多人协作更高效。

> [!TIP]
> Vue 的组件化机制，让开发更加模块化、灵活、可维护，是现代前端框架的核心理念之一。
